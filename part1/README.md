# MicroC Compiler – Phase 1: Scanning and Parsing

This repository contains the initial phase of the MicroC Compiler – a robust, lightweight compiler for a C-like language designed for efficiency and clarity. In this phase, our goal is to validate the syntactic structure of source code by tokenizing the input and constructing its corresponding parse tree.

## Repository Setup

    Clone the Repository:
    Clone the repository to your development machine using your preferred Git client.

    Development Environment:
    Ensure your environment is configured as described in the Project Environment Documentation. This setup includes installing ANTLR, Java (or Python for experimental support), and other required tools.

## Overview

Compilers begin by determining whether a source program is valid—i.e., it uses the correct language vocabulary (keywords, operators, identifiers) and adheres to proper grammar. Our compiler uses two core components for this phase:

    Scanner:
    Reads an input stream of characters and tokenizes them into recognizable units (keywords, operators, literals, etc.).
    Example:
    The code snippet:

'''cur = cur + 4;'''

is tokenized into:
'''
IDENT(cur) OP(ASSIGN) IDENT(cur) OP(PLUS) LIT(4) SEMI
'''
Parser:
Consumes the tokens produced by the scanner to generate a parse tree that represents the hierarchical structure of the program.
Illustration:
The parse tree for the assignment above might appear as follows:

    Parse Tree Example

    The tree decomposes the assignment into its components—identifiers, operators, and expressions—ensuring the program adheres to the defined grammar.

Language Specification
Regular Expressions & Token Definitions

Tokens are defined using regular expressions. In the MicroC.g4 grammar file, you’ll find definitions such as:
'''
IDENTIFIER : LETTER (LETTER | DIGIT)\* ;
INT_LITERAL : DIGIT+ ;
fragment LETTER : ('a'..'z' | 'A'..'Z') ;
fragment DIGIT : ('0'..'9') ;
'''
These definitions are interleaved with the grammar rules to allow for a seamless integration of token and grammar specifications.
Context-Free Grammar

Our grammar defines how high-level constructs (e.g., expressions, statements) are decomposed into smaller components. For example, a simple program is defined as:

program : decls function;

Variable declarations are specified as:

var_decl : 'int' ident ';' ;

And an identifier is defined as:

ident : IDENTIFIER ;

Empty productions are supported for lists of statements:
'''
statements : statement statements
| /_ empty _/ ;
'''
A program is accepted if the tokens generated by the scanner can be produced by the grammar rules starting from the program rule.
ANTLR and Recursive Descent Parsing

ANTLR is used to generate our recursive descent parser. By running the following command, ANTLR generates the necessary Java (or Python) files in the build directory:

'''
$ make
rm -rf build
mkdir build
antlr -o build MicroC.g4
'''
Key generated files include:

    MicroCLexer.java (scanner)
    MicroCParser.java (parser)
    Supporting listener and base classes

To compile and run the parser, use:

javac -cp $CLASSPATH -d classes java/*.java build/*.java
java -cp classes:$CLASSPATH Compiler tests/test1.uC

Successful parsing will output a confirmation (e.g., "Accepted"). An incorrect program will be flagged as "Not Accepted".
Next Steps

This phase lays the foundation for subsequent compiler phases, including semantic analysis, code generation, and optimization. Contributions, improvements, and further feature implementations are welcome as we continue to evolve the MicroC Compiler.

Note: This documentation is intended for developers and contributors interested in building and extending a production-quality compiler.
